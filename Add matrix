def add_matrices(matrix1, matrix2):
    rows, cols = len(matrix1), len(matrix1[0])
    result = [[matrix1[i][j] + matrix2[i][j] for j in range(cols)] for i in range(rows)]
    return result

# User input
rows = int(input("Enter number of rows: "))
cols = int(input("Enter number of columns: "))

print("Enter elements of Matrix 1:")
matrix1 = [[int(input(f"Element [{i+1}][{j+1}]: ")) for j in range(cols)] for i in range(rows)]

print("Enter elements of Matrix 2:")
matrix2 = [[int(input(f"Element [{i+1}][{j+1}]: ")) for j in range(cols)] for i in range(rows)]

result = add_matrices(matrix1, matrix2)
print("Resultant Matrix:")
for row in result:
    print(row)




def bisection_method(func, a, b, tol):
    """
    Find a root of a function using the Bisection Method.

    Parameters:
    func : function
        The nonlinear equation to solve (f(x)).
    a : float
        The lower bound of the interval.
    b : float
        The upper bound of the interval.
    tol : float
        The tolerance level for stopping criteria.

    Returns:
    float
        The root of the equation within the given tolerance.
    """
    if func(a) * func(b) >= 0:
        print("Bisection method fails. The function must have opposite signs at a and b.")
        return None

    while (b - a) / 2.0 > tol:
        midpoint = (a + b) / 2.0
        if func(midpoint) == 0:  # We've found the root
            return midpoint
        elif func(a) * func(midpoint) < 0:  # Root lies in [a, midpoint]
            b = midpoint
        else:  # Root lies in [midpoint, b]
            a = midpoint

    return (a + b) / 2.0

if __name__ == "__main__":
    import sympy as sp

    # Take input for the nonlinear equation
    equation_input = input("Enter the equation in terms of x (e.g., x**3 - 4*x - 9): ")
    x = sp.symbols('x')
    func = sp.lambdify(x, sp.sympify(equation_input), "math")

    # Take input for the interval [a, b]
    a = float(input("Enter the lower bound of the interval (a): "))
    b = float(input("Enter the upper bound of the interval (b): "))

    # Take input for the tolerance
    tol = float(input("Enter the tolerance (e.g., 1e-6): "))

    # Find the root
    root = bisection_method(func, a, b, tol)
    if root is not None:
        print(f"The root of the equation is approximately: {root}")



def bisection_method(func, a, b, tol):
    """
    Find a root of a function using the Bisection Method.

    Parameters:
    func : function
        The nonlinear equation to solve (f(x)).
    a : float
        The lower bound of the interval.
    b : float
        The upper bound of the interval.
    tol : float
        The tolerance level for stopping criteria.

    Returns:
    float
        The root of the equation within the given tolerance.
    """
    if func(a) * func(b) >= 0:
        print("Bisection method fails. The function must have opposite signs at a and b.")
        return None

    while (b - a) / 2.0 > tol:
        midpoint = (a + b) / 2.0
        if func(midpoint) == 0:  # We've found the root
            return midpoint
        elif func(a) * func(midpoint) < 0:  # Root lies in [a, midpoint]
            b = midpoint
        else:  # Root lies in [midpoint, b]
            a = midpoint

    return (a + b) / 2.0


if __name__ == "__main__":
    # Input the equation as a string
    equation_input = input("Enter the equation in terms of x (e.g., x**3 - 4*x - 9): ")

    # Define the function dynamically using eval
    def func(x):
        return eval(equation_input)

    # Input the interval [a, b]
    a = float(input("Enter the lower bound of the interval (a): "))
    b = float(input("Enter the upper bound of the interval (b): "))

    # Input the tolerance
    tol = float(input("Enter the tolerance (e.g., 1e-6): "))

    # Find the root
    root = bisection_method(func, a, b, tol)
    if root is not None:
        print(f"The root of the equation is approximately: {root}")